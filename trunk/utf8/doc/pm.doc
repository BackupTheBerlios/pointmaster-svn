┌────── ┌───
┌────     ┌────
┌────     ┌────           ┌───
┌────     ┌────
┌────── ┌───   ┌── ┌──    ┌───  ┌───    ┌─── ┌── ┌─── ──┐
┌────        ┌───   ┌───  ┌───  ┌───    ┌───     ┌───
┌────        ┌───   ┌───  ┌───  ┌─── ─  ┌───     ┌───
┌────        ┌───   ┌───  ┌───  ┌───  ─ ┌───     ┌───
┌────         ┌─── ┌───   ┌───  ┌───    ┌───     ┌───

┌────      ┌────
┌────      ┌────
┌────      ┌────
┌──── ─  ─ ┌────
┌────  ──  ┌────    ┌─── ┌───  ┌─── ┌───  ┌── ┌─── ──┐ ┌─── ┌──── ┌─── ┌──
┌────      ┌────  ┌───   ┌─── ┌───            ┌───     ┌───       ┌───   ┌───
┌────      ┌──── ┌───    ┌───  ┌─── ┌───      ┌───     ┌─── ┌──   ┌───   ┌───
┌────      ┌──── ┌─── ── ┌───        ┌───     ┌───     ┌───       ┌─── ┌───
┌────      ┌──── ┌───    ┌───  ┌─── ┌───      ┌───     ┌─── ┌──── ┌───   ┌───

А документации-то и нет ! :) Кто хочет написать ? :) Имхо, вполне хватает
хорошо документированных конфигов, ниже есть небольшие пояснения.


                        Логика работы программы:
                        =======================

Логика программы примерно следующая(для начала рекомендую просмотреть конфиги,
там много комментариев):
1.Запускается программа, парсятся конфига, командная строка, проверяются осно-
  вные пути, если все ОК, то идем дальше, иначе выход.
2.Если в комстроке указан параметр /build (или в начальных скриптах установле-
  но значение BuildPointList в Yes), то в память читаются все ListSegment-ы
  (если какого-то из них нет, то программа не ругается, так задумано), если ука-
  зан параметр DeleteListAfterProcess, то после загрузки они удаляется. Затем
  проверяются строки и прочая херня, отсылаются отлупы, затем "мягко" и "жестко"
  автосоздаются сегменты боссов (см. AutoCreateSegment,ForceAutoCreateSegment в
  pntlists.ctl), затем записывается конечный поинтлист DestPointList, затем мас-
  сив боссов из памяти удаляется.
3.Если в комстроке не указан параметр /nomsg, то ищутся письма к программе, если
  найдено хоть одно, то загружаются в память все PointList-ы (опять же, если их
  нет, то не ругается), далее, если указано DeleteListAfterProcess, то удаляются.
  Затем опять все проверяется, опять отлупы и прочее, затем, если были изменения
  в сегменте обработанного босса, то, если он попадает под AutoUpdateSegment (см.
  pntlists.ctl), то его сегмент автоапдейтится (вернее, он просто перезаписывается
  поверх, если его нет, то создается). Затем массив боссов из памяти удаляется.
Описано _очень_ кратко, в описании не учитывал всякие скрипты и прочее, просто
основное.


Теперь о том, как примерно можно применить все эти ListSegment-ы, PointList-ы,
AutoCreateSegment, AutoUpdateSegment и прочее (если кто-то может предоставить
свои конфиги в качестве примера для включения в дистрибутив, буду только рад):
=============================================================================

Ситуация первая:
===============
Вы не хотите, чтобы программа работала с поинтлистом через нетмейл, хотите только
собирать в нужное время поинтлист. Сегменты, например, могут появляться в инба-
унде, оттуда их можно доставать, если немного модифицировать скрипт unarcseg.pms
или как-то самому. ListSegment-ы, например, могут быть следующие (если использо-
вать ExtendedFileMask):
ListSegment %masterpath%\pntlist\seg[#][#][#][#]#.pnt

Задаем маску для создания сегментов, например, чтобы в имени был только номер
ноды:
AutoCreateMask  %masterpath%\pntlist\seg%%node%%.pnt
(ListSegment-ы тогда должны быть с номером ноды, не расширенным до нужного ко-
личества знаков нулем, то есть, например не seg00080 для 80 ноды, а seg80)

Теперь автоматом создаем сегменты для боссов после считывания всех ListSegment:
AutoCreateSegment *

Лучше использовать ForceAutoCreateSegment, потому как в сегментах боссов могут
быть ошибки, после загрузки их в память из них будут исключены все неправильные
строки и, при использовании ForceAutoCreateSegment, сегменты боссов будут переза-
писаны правильными (которые без ошибок), при AutoCreateSegment они перезаписаны
не будут и при следующей сборке программа опять будет ругаться на ошибки (хотя
можно и так и так :)

Конечный поинтлист записываем куда вам нужно, например:
DestPointList      %masterpath%\pntlist\net1998.pnt

Естественно, при этом можно использовать всякие скрипты, менять какие-то пере-
менные в зависимости от чего-нибудь и т.п.

Ситуация вторая:
===============
Вы хотите, чтобы изменения в поинтлист можно было вносить через нетмейл, также
сегменты боссов могут появлять в инбаунде, поэтому их надо как-то согласовывать,
и надо, чтобы этот поинтлист собирался раз в неделю по команде /build
Можно сделать так:

ListSegment  %masterpath%\pntlist\segments\*#
(учтите, что ExtendedFileMask действует только для имени файла, само рекурсивно
обходить каталоги оно не будет :)

Задаем маску для автосоздания и автоапдейта сегментов:
AutoCreateMask   %masterpath%\pntlist\segments\%%node%%
(это если имена сегментов состоят толкьо из номера ноды, меняйте как вам надо)

ForceAutoCreateSegment *
(это чтобы после сборки раз в неделю они опять создались)

Сегменты из инбануда перекидывайте поверх существующих своим скриптом или пере-
делайте unarcseg.pms

PointList   %masterpath%\pntlist\segments\*#

AutoUpdateSegment *
(это чтобы апдейтились сегменты)

DestPointList %masterpath%\pntlist\net1998.pnt
(в данном случае будет каждый раз после писем собираться этот конечный поинт-
лист, что нам надо только раз в неделю, но ничего не поделаешь :)


Ну и т.п., таких ситуаций можно много придумать, вроде все работать должно :)


               Кратко о том, что проверяется в поинтлисте:
               ==========================================
1. Остутствие "левых" символов в поинстроке (границы разрешенных символов можно
   менять)
2. Наличие не менее 6 полей в поинстроке (номер, имя станции, расположение, имя
   сисопа, телефон, скорость)
3. Отстутствие повторяющихся запятых; проверка отстутствия запятой в конце строки
4. Вхождение номера поинта в границы 1..32767
5. Проверка адреса босса: он не должен содержать левых символов и должен
   соответствовать виду Boss,zone:net/node Если после случайно указан номер
   поинта, то программа попытается отрезать от адреса босса все после точки и
   после проверит адрес еще раз, если опять будут косяки, то босс выкидывается
   из поинтлиста.
6. Проверка попадания под маску номера телефона
7. Проверка попадания под маску скорости
8. Проверка наличия повторяющихся(одинаковых) флагов
9. Проверка наличия неизвестных системных флагов (список системных флагов можно
   пополнять)
10. Проверка наличия неизвестных пользовательских флагов (список пользовательских
    флагов можно пополнять)
11. Проверка наличия флагов, уже подразумевающихся другими флагами (этот список
    тоже можно пополнять)
12. При обработки нескольких сегментов также проверяется наличие повторяющихся
    боссов в них.

    При этом почти на каждую их указанных проверок можно поменять реакцию на
    положительный результат, то есть просто ругнуться, ругнуться и не включать
    данную поинтстроку в поинтлист, игнорировать ошибку; при этом также можно
    указать кому ругаться (только в лог; в лог и сисопу; в лог, сисопу и боссу)


                 Большое спасибо следующим людям и фирмам:
                 ========================================

Dmitriy Nevozhai (2:5045/52) - за то, что тестировал мою программу, предложил
                               ряд новых фич, да и вообще, за то, что пинал
                               меня и я что-то делал :)
Alexey Volkov (2:450/173.9)  - за то, что стал первым зарегистрированным поль-
                               зователем и распространителем
Alexander Govyazin (2:6002/0)- за то, что находил баги и вносил предложения,
                               правда, многие из них я еще не реализовал ;)
Sergey S. Lazaretov          - за то, что тестировал, пинал меня и прочее :)
Неизвестному автору          - за его ExecWithSwap, где взял, не могу сказать,
                               винты слетали и вся информация потеряна :(
Borland Inc.                 - за Borland Pascal with Objects 7.01 (все оста-
                               льное мое :)
fPrint                       - За замечательный Virtual Pascal 2.0

Все, больше никого нет :) Вместо того, чтобы читать этот файл, мог бы предло-
жит что-нибудь и ты тоже бы тут появился :)


                 Ограничения DOS и DPMI-версий программы:
                 =======================================

Максимальное количество переменных (из всех файлов)      -  16380
Максимальное количество значений  у переменных,
которые могут иметь множество значений                   -  16380
Максимальное количество боссов                           -  16380
Максимальное количество поинтов/строк комментариев
у каждого босса                                          -  16380

                 Ограничения WIN32 и OS/2-версий программы
                 (брать на http://pointmaster.webjump.com):
                 =========================================

Максимальное количество переменных (из всех файлов)      -  2147483647 ;)
Максимальное количество значений  у переменных,
которые могут иметь множество значений                   -  2147483647
Максимальное количество боссов                           -  2147483647
Максимальное количество поинтов/строк комментариев
у каждого босса                                          -  2147483647

Максимальный размер поинтлиста, который может быть обработан зависит только
от размера свободной памяти, которая есть после запуска программы.

                             Общие ограничения:
                             =================
Максимальная длина строки (в поинтлистах,
в скриптах, конфигах и т.д.)                              - 255 символов
