{$I VERSION.INC}
{$I-,V-,S-,R-} { It is required to turn off abort on I/O error with $I- }
Unit FileCopy;

interface

uses
{$IFDEF VIRTUALPASCAL}
Use32,
{$ENDIF}
DOS,Incl,Parser,Logger;

type
  Path             = String[70]; { to store filespecs }

function File_Copy_Buf(Source,Dest : Path;
                       BufPtr : Pointer; BufferSize : Word;IsMove:Boolean;WriteLog:Boolean) : Word;
{
  Copies file specified by Source into file specified by Dest using a
  buffer BufferSize bytes in size and pointed to by BufPtr.  The function
  result is the error code. If the error code is zero, then the file was
  successfully copied.  The filenames may optionally include drive and/or
  pathnames.  If the destination file already exists, it will be
  overwritten.  If ErrorCode nonzero, then it is the IOResult value
  that signaled the error.  A special value of $FFFF indicates
  that the destination disk filled before the entire file was copied.
  I would suggest that you delete the destination file if an error
  occurs and the destination file was created (like a read/write
  or disk full error) since this routine will not do that for you.
}

function File_Copy(Source,Dest : Path; BufferSize : Word;IsMove:Boolean;WriteLog:Boolean) : Word;
{
  Same as File_Copy_Buf except automatically allocates a buffer of
  BufferSize bytes on the heap, so no pointer need be passed.
}

implementation
Uses StrUnit
     {$IFNDEF SPLE}
     ,Script
     {$ENDIF};

function File_Copy_Buf(Source,Dest : Path;
                       BufPtr : Pointer; BufferSize : Word;IsMove:Boolean;WriteLog:Boolean) : Word;

var
  InF,OutF         : File;    { the input and output files }
  ErrorCode,Num,N  : Word;    { a few words }
  Time             : LongInt; { to hold time/date stamp }

begin
  If StrUp(FExpand(Source))=StrUp(FExpand(Dest)) Then
     Begin
      If IsMove Then
        Begin
         If StrUp(GetVar(LanguageTag.Tag,_varNONE))=EnglishTag Then
            LogWriteLn('!Can''t move to itself: '+FExpand(Source))
         Else
            LogWriteLn('!Hе могy пеpеместить файл на самого себя: '+FExpand(Source))
        End
      Else
        Begin
         If StrUp(GetVar(LanguageTag.Tag,_varNONE))=EnglishTag Then
            LogWriteLn('!Can''t copy to itself: '+FExpand(Source))
         Else
            LogWriteLn('!Hе могy скопиpовать файл на самого себя: '+FExpand(Source))
        End;
      DosError:=18;
      File_Copy_Buf:=18;
      Exit;
     End;
  FileMode:=($40);
  Assign(InF,Source);
  Reset(InF,1);           { open the source file }
  ErrorCode := IOResult;
  If ErrorCode=0 Then
  Begin
  GetFTime(InF,Time);     { get time/date stamp from source file }
  if IOResult = 0 then
   begin
    FileMode:=$42;
    Assign(OutF,Dest);
    Rewrite(OutF,1);      { Create destination file }
    ErrorCode := IOResult;
    If ErrorCode<>0 Then
       Begin
        LogWriteLn(GetMakingString(_logCantOpenFile)+FExpand(Dest));
        {$IFNDEF SPLE}
        LogWriteDosError(ErrorCode,GetMakingString(_logDosError));
        {$ENDIF}
        Close(InF);
        If IOResult<>0 Then;
        FileMode:=$42;
        Exit;
       End;
    { copy loop }
    while (not EOF(InF)) and (ErrorCode = 0) do
     begin
      BlockRead(InF,BufPtr^,BufferSize,Num); { read a buffer full from source }
      ErrorCode := IOResult;
      if ErrorCode = 0 then
       begin
        BlockWrite(OutF,BufPtr^,Num,N);      { write it to destintion }
        ErrorCode := IOResult;
        if N < Num then
          ErrorCode := $FFFF;   { disk probably full }
       end;
    end;
  end
 Else
  Begin
    LogWriteLn(GetMakingString(_logCantOpenFile)+FExpand(Source));
    {$IFNDEF SPLE}
    LogWriteDosError(ErrorCode,GetMakingString(_logDosError));
    {$ENDIF}
    FileMode:=$42;
    Exit;
  End;
  End
  Else
   begin
    LogWriteLn(GetMakingString(_logCantOpenFile)+FExpand(Source));
    {$IFNDEF SPLE}
    LogWriteDosError(ErrorCode,GetMakingString(_logDosError));
    {$ENDIF}
    FileMode:=$42;
    Exit;
   End;
  { error detection and reporting could be alot better, }
  { but what do ya want for nothin? }

  { try to close the files no matter what to make sure handles are freed }
  Close(OutF);      { Close destination file }
  if IOresult <> 0 then ;
  Close(InF);       { close source file }
  FileMode:=$42;
  if IOResult = 0 then begin
    Assign(OutF,Dest);
    Reset(OutF);
    if IOResult <> 0 then ;  { clear IOResult }
    SetFTime(OutF,Time);     { Set time/date stamp of dest to that of source }
    Close(OutF);
    if IOresult <> 0 then ;
  end;
  File_Copy_Buf := ErrorCode;
  If IsMove Then
     Begin
      {$I-}
      Erase(InF);
      {$I+}
      ErrorCode:=IOresult;
      If ErrorCode<>0 Then
        Begin
         File_Copy_Buf:=ErrorCode;
         LogWriteLn(GetMakingString(_logCantDeleteFile)+FExpand(Source));
         {$IFNDEF SPLE}
         LogWriteDosError(ErrorCode,GetMakingString(_logDosError));
         {$ENDIF}
        End;
     End;
If WriteLog Then
 Begin
  If IsMove Then
    Begin
     If StrUp(GetVar(LanguageTag.Tag,_varNONE))=EnglishTag Then
        LogWriteLn('#Done move '+FExpand(Source)+' to '+FExpand(Dest))
     Else
        LogWriteLn('#Пеpемещен '+FExpand(Source)+' в '+FExpand(Dest))
    End
  Else
    Begin
     If StrUp(GetVar(LanguageTag.Tag,_varNONE))=EnglishTag Then
        LogWriteLn('#Done copy '+FExpand(Source)+' to '+FExpand(Dest))
     Else
        LogWriteLn('#Скопиpован '+FExpand(Source)+' в '+FExpand(Dest))
    End;
 End;
end;

function File_Copy(Source,Dest : Path; BufferSize : Word;IsMove:Boolean;WriteLog:Boolean) : Word;
{ shell around File_Copy_Buf to automatically allocate a buffer of }
{ BufferSize on the heap }
var
  Buf              : Pointer;

begin
  if BufferSize > 65521 then
    BufferSize := 65521;  { user specified buffer bigger than possible }
                          { so scale it down }
  GetMem(Buf,BufferSize); { allocate memory for the buffer }
  File_Copy := File_Copy_Buf(Source,Dest,Buf,BufferSize,IsMove,WriteLog);
  FreeMem(Buf,BufferSize); { deallocate heap space for buffer }
end;

end.
